<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>è™šæ‹Ÿå¼€å¥–ç¨‹åº - æ™ºèƒ½é¢„æµ‹</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
      background: #f0f0f0;
    }
    .sidebar {
      width: 200px;
      background: #333;
      color: white;
      padding-top: 20px;
    }
    .sidebar button {
      width: 100%;
      padding: 15px;
      border: none;
      background: none;
      color: white;
      font-size: 16px;
      text-align: left;
      cursor: pointer;
    }
    .sidebar button:hover {
      background: #444;
    }
    .content {
      flex-grow: 1;
      padding: 20px;
    }
    .log {
      white-space: pre-wrap;
      background: #fff;
      padding: 15px;
      border: 1px solid #ccc;
      height: 400px;
      overflow-y: scroll;
    }
    input { padding: 5px; font-size: 16px; }
    button.submit-btn { padding: 5px 10px; font-size: 16px; }
  </style>
</head>
<body>
  <div class="sidebar">
    <button onclick="setMode(30)">ğŸ° æ¯30ç§’å¼€å¥–</button>
    <button onclick="setMode(60)">â±ï¸ æ¯1åˆ†é’Ÿå¼€å¥–</button>
  </div>

  <div class="content">
    <h2 id="title">ğŸ° æ¯30ç§’å¼€å¥– | æ˜¾ç¤ºç»“æœåå¯è¾“å…¥ | è‡ªåŠ¨é¢„æµ‹ä¸‹ä¸€è½®</h2>
    <div class="log" id="log"></div>
    <div>
      <label for="userInput">âŒ¨ï¸ è¯·è¾“å…¥å¼€å¥–å·ç ï¼ˆ0-9ï¼‰: </label>
      <input type="number" id="userInput" min="0" max="9">
      <button class="submit-btn" onclick="submitNumber()">æäº¤</button>
    </div>
  </div>

  <script>
    let roundNum = 1;
    let history = [];
    let lastPredicted = null;
    let inputAllowed = false;
    let timeoutId = null;
    let currentInterval = 30;

    const strategyNames = {
      guessNearby: "ç›¸é‚»å·æ³•",
      guessHot: "çƒ­å·ç­–ç•¥",
      guessCold: "å†·å·ç­–ç•¥",
      guessRepeat: "é‡å¤ç­–ç•¥",
      guessFlipOddEven: "å¥‡å¶äº’è½¬",
      guessDiagonalJump: "æ–œè·³èµ°åŠ¿",
      guessByVibe: "å¿ƒç†æ„Ÿè§‰æ³•"
    };

    function rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function log(message) {
      const logDiv = document.getElementById("log");
      logDiv.innerText += message + "\n";
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function clearAll() {
      document.getElementById("log").innerText = "";
      roundNum = 1;
      history = [];
      lastPredicted = null;
      inputAllowed = false;
      if (timeoutId) clearTimeout(timeoutId);
    }

    function getSize(num) {
      return num <= 4 ? "å°" : "å¤§";
    }

    function getColor(num) {
      if (num === 0) return ["çº¢è‰²", "ç´«è‰²"];
      if (num === 5) return ["ç»¿è‰²", "ç´«è‰²"];
      return num % 2 === 0 ? ["çº¢è‰²"] : ["ç»¿è‰²"];
    }

    function getColorIcon(color) {
      const icons = { "çº¢è‰²": "ğŸ”´", "ç»¿è‰²": "ğŸŸ¢", "ç´«è‰²": "ğŸŸ£" };
      return icons[color] || color;
    }

    function formatColorIcons(colors) {
      return colors.map(c => getColorIcon(c)).join(" ");
    }

    // --------- æ™ºèƒ½é¢„æµ‹ç­–ç•¥é›† ---------

    function guessNearby(history) {
      const base = history[history.length - 1][0];
      const num = Math.max(0, Math.min(9, base + rand(-1, 1)));
      return [num, getSize(num)];
    }

    function guessHot(history) {
      const freq = Array(10).fill(0);
      history.forEach(h => h && freq[h[0]]++);
      const hot = freq.indexOf(Math.max(...freq));
      return [hot, getSize(hot)];
    }

    function guessCold(history) {
      const freq = Array(10).fill(0);
      history.forEach(h => h && freq[h[0]]++);
      const cold = freq.indexOf(Math.min(...freq));
      return [cold, getSize(cold)];
    }

    function guessRepeat(history) {
      const num = history[history.length - 1][0];
      return [num, getSize(num)];
    }

    function guessFlipOddEven(history) {
      const last = history[history.length - 1][0];
      const num = (last % 2 === 0) ? last + 1 : last - 1;
      const safeNum = (num < 0 || num > 9) ? rand(0, 9) : num;
      return [safeNum, getSize(safeNum)];
    }

    function guessDiagonalJump(history) {
      if (history.length < 2) return [rand(0, 9), getSize(rand(0, 9))];
      const n1 = history[history.length - 1][0];
      const n2 = history[history.length - 2][0];
      const diff = n1 - n2;
      const predicted = n1 + diff;
      const safe = Math.max(0, Math.min(9, predicted));
      return [safe, getSize(safe)];
    }

    function guessByVibe(history) {
      const vibeNums = [3, 6, 8, 0, 9, 5, 1];
      const num = vibeNums[rand(0, vibeNums.length - 1)];
      return [num, getSize(num)];
    }

    function smartPredictor(history) {
      if (history.length === 0) {
        const num = rand(0, 9);
        return { num, size: getSize(num), strategy: "éšæœºåˆå§‹" };
      }

      const strategies = [
        guessNearby,
        guessHot,
        guessCold,
        guessRepeat,
        guessFlipOddEven,
        guessDiagonalJump,
        guessByVibe
      ];
      const chosen = strategies[rand(0, strategies.length - 1)];
      const [num, size] = chosen(history);
      return { num, size, strategy: strategyNames[chosen.name] || "æœªçŸ¥" };
    }

    function drawRound() {
      const now = new Date();
      const timeStr = now.toTimeString().split(" ")[0];
      log(`\nâ° ç¬¬ ${roundNum} è½®å¼€å¥–æ—¶é—´ - ${timeStr}`);
      log("ğŸ² æ­£åœ¨å¼€å¥–ä¸­â€¦â€¦");
      inputAllowed = true;

      timeoutId = setTimeout(() => {
        if (inputAllowed) {
          log("âš ï¸ æœªè¾“å…¥æˆ–è¾“å…¥æ— æ•ˆï¼Œæœ¬è½®è·³è¿‡");
          history.push(null);
          afterDraw();
        }
      }, 15000);
    }

    function submitNumber() {
      if (!inputAllowed) return;
      const input = document.getElementById("userInput").value;
      const num = parseInt(input);
      if (!isNaN(num) && num >= 0 && num <= 9) {
        clearTimeout(timeoutId);
        const size = getSize(num);
        const colors = getColor(num);
        log(`ğŸ¯ å¼€å¥–ç»“æœï¼š${num} -> ${size} | é¢œè‰²ï¼š${formatColorIcons(colors)}`);
        history.push([num, size, colors]);
        inputAllowed = false;
        afterDraw();
      } else {
        log("âš ï¸ è¾“å…¥æ— æ•ˆï¼Œè¯·è¾“å…¥ 0-9 çš„æ•°å­—");
      }
    }

    function afterDraw() {
      const cleanHistory = history.filter(h => h !== null);
      const prediction = smartPredictor(cleanHistory);
      const predictedColors = getColor(prediction.num);

      log(`ğŸ”® é¢„æµ‹ç¬¬ ${roundNum + 1} è½®ï¼š${prediction.num} -> ${prediction.size} | é¢œè‰²ï¼š${formatColorIcons(predictedColors)}`);
      log(`ğŸ§  ä½¿ç”¨ç­–ç•¥ï¼š${prediction.strategy}`);
      log(`----------------------`);

      if (lastPredicted && history.length >= 1) {
        const actual = history[history.length - 1];
        if (actual) {
          const [actNum, actSize, actColors] = actual;
          const matchNum = actNum === lastPredicted.num ? "âœ…" : "âŒ";
          const matchSize = actSize === lastPredicted.size ? "âœ…" : "âŒ";
          const matchColor = getColor(lastPredicted.num).some(c => actColors.includes(c)) ? "âœ…" : "âŒ";

          log(`ğŸ“‹ ä¸Šè½®é¢„æµ‹æ¯”å¯¹ï¼š`);
          log(`å·ç ï¼š${lastPredicted.num} ${matchNum}`);
          log(`é¢œè‰²ï¼š${formatColorIcons(getColor(lastPredicted.num))} ${matchColor}`);
          log(`å¤§å°ï¼š${lastPredicted.size} ${matchSize}`);
        } else {
          log("ğŸ“‹ ä¸Šè½®é¢„æµ‹æ¯”å¯¹ï¼šæ— æ•°æ®");
        }
      }

      lastPredicted = prediction;
      roundNum++;
    }

    function setMode(intervalSec) {
      clearAll();
      currentInterval = intervalSec;
      const titleMap = {
        30: "ğŸ° æ¯30ç§’å¼€å¥–",
        60: "â±ï¸ æ¯1åˆ†é’Ÿå¼€å¥–"
      };
      document.getElementById("title").innerText = `${titleMap[intervalSec]} | æ˜¾ç¤ºç»“æœåå¯è¾“å…¥ | è‡ªåŠ¨é¢„æµ‹ä¸‹ä¸€è½®`;
      log(`ğŸ”„ åˆ‡æ¢åˆ°ã€${intervalSec}ç§’ã€‘æ¨¡å¼ï¼Œå·²é‡ç½®æ•°æ®`);
    }

    // é»˜è®¤å¯åŠ¨ 30 ç§’æ¨¡å¼
    setMode(30);

    setInterval(() => {
      const now = new Date();
      if (now.getSeconds() % currentInterval === 0 && now.getMilliseconds() < 1000) {
        drawRound();
      }
    }, 1000);
  </script>
</body>
</html>
