<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>è™šæ‹Ÿå¼€å¥–ç¨‹åº</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; padding: 20px; }
    .log { white-space: pre-wrap; background: #fff; padding: 15px; border: 1px solid #ccc; height: 400px; overflow-y: scroll; }
    input { padding: 5px; font-size: 16px; }
    button { padding: 5px 10px; font-size: 16px; }
  </style>
</head>
<body>
  <h2>ğŸ° æ¯30ç§’å¼€å¥– | æ˜¾ç¤ºç»“æœåå¯è¾“å…¥ | è‡ªåŠ¨é¢„æµ‹ä¸‹ä¸€è½®</h2>
  <div class="log" id="log"></div>
  <div>
    <label for="userInput">âŒ¨ï¸ è¯·è¾“å…¥å¼€å¥–å·ç ï¼ˆ0-9ï¼‰: </label>
    <input type="number" id="userInput" min="0" max="9">
    <button onclick="submitNumber()">æäº¤</button>
  </div>

  <script>
    let roundNum = 1;
    let history = [];
    let lastPredicted = null;
    let inputAllowed = false;
    let timeoutId = null;

    function log(message) {
      const logDiv = document.getElementById("log");
      logDiv.innerText += message + "\n";
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function getSize(num) {
      return num <= 4 ? "å°" : "å¤§";
    }

    function getColor(num) {
      if (num === 0) return ["çº¢è‰²", "ç´«è‰²"];
      if (num === 5) return ["ç»¿è‰²", "ç´«è‰²"];
      return num % 2 === 0 ? ["çº¢è‰²"] : ["ç»¿è‰²"]; // å¥‡æ•° â†’ ç»¿è‰²
    }

    function getColorIcon(color) {
      const icons = {
        "çº¢è‰²": "ğŸ”´",
        "ç»¿è‰²": "ğŸŸ¢",
        "ç´«è‰²": "ğŸŸ£"
      };
      return icons[color] || color;
    }

    function formatColorIcons(colors) {
      return colors.map(c => getColorIcon(c)).join(" ");
    }

    function predictNext(history) {
      if (history.length === 0) {
        const num = Math.floor(Math.random() * 10);
        return [num, getSize(num)];
      }
      const smallCount = history.filter(h => h && h[1] === "å°").length;
      const bigCount = history.length - smallCount;
      const num = bigCount > smallCount ? rand(5, 9) : rand(0, 4);
      return [num, getSize(num)];
    }

    function rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function drawRound() {
      const now = new Date();
      const timeStr = now.toTimeString().split(" ")[0];
      log(`\nâ° ç¬¬ ${roundNum} è½®å¼€å¥–æ—¶é—´ - ${timeStr}`);
      log("ğŸ² æ­£åœ¨å¼€å¥–ä¸­â€¦â€¦");
      inputAllowed = true;

      timeoutId = setTimeout(() => {
        if (inputAllowed) {
          log("âš ï¸ æœªè¾“å…¥æˆ–è¾“å…¥æ— æ•ˆï¼Œæœ¬è½®è·³è¿‡ï¼ˆæœªè®°å½•å¼€å¥–å·ç ï¼‰");
          history.push(null);
          afterDraw();
        }
      }, 15000);
    }

    function submitNumber() {
      if (!inputAllowed) return;
      const input = document.getElementById("userInput").value;
      const num = parseInt(input);
      if (!isNaN(num) && num >= 0 && num <= 9) {
        clearTimeout(timeoutId);
        const size = getSize(num);
        const colors = getColor(num);
        log(`ğŸ¯ å¼€å¥–ç»“æœï¼š${num} -> ${size} | é¢œè‰²ï¼š${formatColorIcons(colors)}`);
        history.push([num, size, colors]);
        inputAllowed = false;
        afterDraw();
      } else {
        log("âš ï¸ è¾“å…¥æ— æ•ˆï¼Œè¯·è¾“å…¥ 0-9 çš„æ•°å­—");
      }
    }

    function afterDraw() {
      const cleanHistory = history.filter(entry => entry !== null);
      const [predictedNum, predictedSize] = predictNext(cleanHistory);
      const predictedColors = getColor(predictedNum);

      log(`ğŸ”® é¢„æµ‹ç¬¬ ${roundNum + 1} è½®å·ç ï¼š${predictedNum} -> ${predictedSize} | é¢œè‰²ï¼š${formatColorIcons(predictedColors)}`);
      log(`----------------------`);

      // æ¯”å¯¹é¢„æµ‹ï¼ˆæœ¬è½®å¼€å¥–ç»“æœ vs ä¸Šä¸€è½®é¢„æµ‹ï¼‰
      if (lastPredicted !== null && history.length >= 1) {
        const lastActual = history[history.length - 1];
        if (lastActual) {
          const [actualNum, actualSize, actualColors] = lastActual;
          const [predNum, predSize] = lastPredicted;
          const predColors = getColor(predNum);

          const matchNumber = actualNum === predNum ? "âœ…" : "âŒ";
          const matchSize = actualSize === predSize ? "âœ…" : "âŒ";
          const matchColor = predColors.some(c => actualColors.includes(c)) ? "âœ…" : "âŒ";

          log(`ğŸ“‹ ä¸Šè½®é¢„æµ‹ç»“æœï¼š`);
          log(`å·ç ï¼š${predNum} ${matchNumber}`);
          log(`é¢œè‰²ï¼š${formatColorIcons(predColors)} ${matchColor}`);
          log(`å¤§å°ï¼š${predSize} ${matchSize}`);
        } else {
          log("ğŸ“‹ ä¸Šè½®é¢„æµ‹ç»“æœï¼šæ— å¼€å¥–æ•°æ®ï¼Œæ— æ³•æ¯”å¯¹");
        }
      }

      lastPredicted = [predictedNum, predictedSize];
      roundNum += 1;
    }

    // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦åˆ° 30 ç§’æ—¶ç‚¹ï¼Œè§¦å‘ drawRound()
    setInterval(() => {
      const now = new Date();
      if (now.getSeconds() % 30 === 0) {
        drawRound();
      }
    }, 1000);
  </script>
</body>
</html>
